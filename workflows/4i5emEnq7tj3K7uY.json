{
  "active": true,
  "connections": {
    "Redis Trigger": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Chat Memory Manager1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Memory Manager1": {
      "main": [
        [
          {
            "node": "limpiamos msg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "limpiamos msg": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "If4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [
          {
            "node": "contador de mensajes",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "escribiendo...1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out1": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Separa datos1": {
      "main": [
        [
          {
            "node": "Split Out1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "escribiendo...1": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If4": {
      "main": [
        [],
        [
          {
            "node": "Separa datos1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "memory2": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "memory": {
      "ai_memory": [
        [
          {
            "node": "Chat Memory Manager1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "usuario",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "usuario": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis": {
      "main": [
        []
      ]
    },
    "contador de mensajes": {
      "main": [
        [
          {
            "node": "Envio el 3er msg?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Envio el 3er msg?": {
      "main": [
        [],
        [
          {
            "node": "ultimoMsg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ultimoMsg": {
      "main": [
        [
          {
            "node": "Redis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-08-14T18:21:11.005Z",
  "id": "4i5emEnq7tj3K7uY",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "AGENTE CITAS - FOLLOW UP QEVA",
  "nodes": [
    {
      "parameters": {
        "channels": "=__keyevent@0__:expired",
        "options": {
          "jsonParseBody": true,
          "onlyMessage": false
        }
      },
      "type": "n8n-nodes-base.redisTrigger",
      "typeVersion": 1,
      "position": [
        -2400,
        112
      ],
      "id": "e77f5884-be94-4a5f-8cf7-fb7752de7344",
      "name": "Redis Trigger",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c34ea9fc-ce79-478f-9c07-e4e6a6eed15d",
              "name": "usuario",
              "value": "={{ ($json.message.match(/usuario:(\\d+):ultimomsg/) || [])[1] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1776,
        -48
      ],
      "id": "5acdc929-29d1-4ae0-b15c-52fe74aebe75",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "options": {
          "groupMessages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.memoryManager",
      "typeVersion": 1.1,
      "position": [
        -1440,
        -192
      ],
      "id": "bf8fc45c-e95b-4ae1-956a-647da8854163",
      "name": "Chat Memory Manager1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "e325c5b3-b99c-43da-a5c8-a478c9048312",
              "name": "msg",
              "value": "={{ $json.messages.slice(-2).map(m => 'Usuario: ' + m.human + '\\n\\nAgente: ' + m.ai).join('\\n\\n---\\n\\n') }}",
              "type": "string"
            },
            {
              "id": "98f4cd87-7d6e-4b0a-a2b3-190095da6110",
              "name": "telefono",
              "value": "={{ $('Edit Fields').item.json.usuario }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1024,
        -48
      ],
      "id": "d7bc9a94-c8d7-4092-98cb-2dff20451ae9",
      "name": "limpiamos msg"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Conversacion previa: {{ $json.msg }}",
        "options": {
          "systemMessage": "=# PROMPT PARA SUB-AGENTE DE CONTINUIDAD DE CONVERSACIÓN\n\n## REGLA ABSOLUTA\n**Devuelve exactamente `FINALIZADO` (en mayúsculas, sin comillas ni texto extra) si se cumple cualquiera de estas condiciones:**\n- El usuario se despide explícitamente: \"chau\", \"adiós\", \"hasta luego\", \"no gracias\", \"no necesito nada más\", \"listo, gracias\".\n- **Cualquier mensaje (del usuario o del agente) contiene la cadena `button_confirm`** (insensible a mayúsculas/minúsculas), por ejemplo: `Agente: button_confirm`.\n\n**En TODOS los demás casos → Genera ÚNICAMENTE una pregunta o mensaje de seguimiento directo.**\n\n> Implementación sugerida (lógica interna): si `texto_total` cumple `/button_confirm\\b/i` → responder `FINALIZADO`.\n\n## INSTRUCCIONES CRÍTICAS\n\n### NO HAGAS ESTO:\n❌ NO expliques tu razonamiento  \n❌ NO digas \"Gracias por la información\"  \n❌ NO resumas lo que dijo el usuario  \n❌ NO repitas información ya dicha  \n❌ NO reflexiones sobre la conversación  \n\n### SÍ HAZ ESTO:\n✅ SOLO genera la siguiente pregunta directa  \n✅ Continúa el flujo natural de la conversación  \n✅ Sé directo y conciso  \n✅ Variá las preguntas si no hay respuesta  \n\n## EJEMPLOS CORRECTOS\n\n### Situación: Usuario dio su nombre completo\n- Usuario: \"Genial, ¿qué día y horario te quedan mejor para agendar la limpieza?\"\n→ **Tu respuesta:** \"¿Preferís turno de mañana o tarde?\"\n\n### Situación: Usuario eligió servicio\n- Usuario: \"Limpieza\"\n→ **Tu respuesta:** \"¿Qué día te queda mejor?\"\n\n### Situación: Usuario no responde (primera vez)\n- Agente: \"¿En qué puedo ayudarte?\"\n- Usuario: (sin respuesta)\n→ **Tu respuesta:** \"¿Necesitás agendar un turno?\"\n\n### Situación: Usuario no responde (segunda vez)\n- Agente: \"¿Necesitás agendar un turno?\"\n- Usuario: (sin respuesta)\n→ **Tu respuesta:** \"¿Querés información sobre algún tratamiento?\"\n\n### Situación: Confirmación por botón\n- Secuencia:\n  - Usuario: \"Fernando alonso\"\n  - Agente: \"Bárbaro, Fernando. ¿Para qué servicio sería el turno?\"\n  - Usuario: \"Para limpieza\"\n  - **Agente: \"button_confirm\"**\n→ **Tu respuesta:** `FINALIZADO`\n\n## FORMATO DE RESPUESTA\n**Opción 1:** `FINALIZADO` (solo si aplica la regla absoluta)  \n**Opción 2:** [Solo la pregunta directa, sin explicaciones]\n\n## VALIDACIÓN ANTES DE RESPONDER\n1. ¿Es solo una pregunta sin explicaciones? ✓  \n2. ¿Es diferente a las preguntas anteriores? ✓  \n3. ¿Continúa naturalmente la conversación? ✓  \n4. ¿Es de 1–2 líneas máximo? ✓  \n\n## RECUERDA\n- **NUNCA** expliques, solo preguntá  \n- **NUNCA** agradezcas, solo continuá  \n- **NUNCA** resumas, solo avanzá  \n- Si dudás → hacé la siguiente pregunta lógica\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -768,
        -192
      ],
      "id": "5a588a38-7708-4035-bdea-65064b6822ba",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": "google/gemini-2.5-flash",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -896,
        176
      ],
      "id": "700946f9-57d4-48f2-903c-0f52f8340bfe",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "ADdm45cFSIFSG59w",
          "name": "Gemini"
        }
      }
    },
    {
      "parameters": {
        "batchSize": "=1",
        "options": {
          "reset": false
        }
      },
      "id": "600351fa-b0d4-43c3-bb01-b929c2c06627",
      "name": "Loop Over Items1",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        512,
        -48
      ],
      "alwaysOutputData": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "fieldToSplitOut": "messages",
        "options": {}
      },
      "id": "10e23d61-18e3-41d3-adbc-494bf03faa10",
      "name": "Split Out1",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        0,
        -48
      ]
    },
    {
      "parameters": {
        "jsCode": "// --- Funciones de procesamiento de texto ---\n\n// Función para dividir texto en fragmentos con tiempo de lectura\nfunction splitTextIntoChunks(text, maxChars = 200) {\n  // Si el texto es muy corto, devolvemos un solo fragmento\n  if (!text || text.length <= maxChars) {\n    return [{\n      parte: 1,\n      texto: text || '',\n      time: calculateReadingTime(text || '')\n    }];\n  }\n\n  const chunks = [];\n  let currentChunk = '';\n  let partNumber = 1;\n  \n  // Dividimos por palabras para no cortar palabras a la mitad\n  const words = text.split(' ');\n  \n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const potentialChunk = currentChunk ? currentChunk + ' ' + word : word;\n    \n    // Si agregar la siguiente palabra excede el límite\n    if (potentialChunk.length > maxChars) {\n      // Si la palabra sola es más larga que maxChars, la cortamos\n      if (word.length > maxChars) {\n        // Guardamos el chunk actual si tiene contenido\n        if (currentChunk) {\n          chunks.push({\n            parte: partNumber++,\n            texto: currentChunk.trim(),\n            time: calculateReadingTime(currentChunk.trim())\n          });\n        }\n        \n        // Cortamos la palabra larga en pedazos\n        let remainingWord = word;\n        while (remainingWord.length > maxChars) {\n          chunks.push({\n            parte: partNumber++,\n            texto: remainingWord.substring(0, maxChars),\n            time: calculateReadingTime(remainingWord.substring(0, maxChars))\n          });\n          remainingWord = remainingWord.substring(maxChars);\n        }\n        \n        // El resto de la palabra se convierte en el nuevo currentChunk\n        currentChunk = remainingWord;\n      } else {\n        // Guardamos el chunk actual y empezamos uno nuevo con esta palabra\n        chunks.push({\n          parte: partNumber++,\n          texto: currentChunk.trim(),\n          time: calculateReadingTime(currentChunk.trim())\n        });\n        currentChunk = word;\n      }\n    } else {\n      // Si cabe, agregamos la palabra al chunk actual\n      currentChunk = potentialChunk;\n    }\n  }\n  \n  // Agregar el último chunk si queda algo\n  if (currentChunk.trim()) {\n    chunks.push({\n      parte: partNumber,\n      texto: currentChunk.trim(),\n      time: calculateReadingTime(currentChunk.trim())\n    });\n  }\n  \n  return chunks;\n}\n\n// Función para calcular el tiempo de lectura basado en la longitud del texto\nfunction calculateReadingTime(text) {\n  const length = text.length;\n  \n  if (length > 150) {\n    return 4; // segundos\n  } else if (length >= 50) {\n    return 3; // segundos\n  } else {\n    return 1; // segundo\n  }\n}\n\n// Función para determinar si un texto necesita ser dividido\nfunction needsSplitting(text) {\n  if (!text || typeof text !== 'string') return false;\n  \n  // Criterios: más de 500 caracteres o más de 100 palabras\n  const charCount = text.length;\n  const wordCount = text.split(/\\s+/).filter(word => word.length > 0).length;\n  \n  return charCount > 500 || wordCount > 100;\n}\n\n// Función para procesar el texto y dividirlo inteligentemente (función original mejorada)\nfunction processAndSplitText(textInput) {\n  // Asegúrate de que textInput sea un string o pueda ser convertido\n  let text = textInput;\n\n  // Si la entrada no es un string\n  if (typeof text !== 'string') {\n    // Si es null o undefined, simplemente devolvemos un array vacío\n    if (text === null || text === undefined) {\n      return [];\n    }\n\n    // Si es un objeto, intentamos encontrar campos comunes que contengan texto\n    if (typeof text === 'object') {\n      if (text.text) {\n        text = text.text;\n      } else if (text.message) {\n        text = text.message;\n      } else if (text.type === 'text' && text.text) {\n        text = text.text;\n      } else if (text.output) {\n        // Si output es un string, lo usamos\n        if (typeof text.output === 'string') {\n          text = text.output;\n        } else {\n          // Si output es un objeto o array, intentamos extraer de ahí\n          const extracted = extractTextContent(text.output);\n          if (extracted) {\n            text = extracted;\n          } else {\n            // Si no pudimos extraer, intentamos convertir todo el objeto a string\n            try {\n              text = JSON.stringify(text);\n            } catch (e) {\n              console.error(\"No se pudo serializar el objeto a string:\", e);\n              return [];\n            }\n          }\n        }\n      } else {\n        // Si no encontramos campos de texto comunes ni 'output', intentamos convertir a string\n        try {\n          text = JSON.stringify(text);\n        } catch (e) {\n          console.error(\"No se pudo serializar el objeto a string:\", e);\n          return [];\n        }\n      }\n    } else {\n      // Si no es string, objeto, null o undefined, devolvemos vacío\n      console.warn(\"Entrada a processAndSplitText no es string, objeto, null o undefined:\", typeof text);\n      return [];\n    }\n  }\n\n  // Si después de los intentos no tenemos un string válido, devolvemos vacío\n  if (typeof text !== 'string' || text.trim() === '') {\n    return [];\n  }\n\n  // Ahora que tenemos un string, procesamos el formato\n  const processedText = text\n    .replace(/\\*\\*(.+?)\\*\\*/g, '*$1*') // **texto** -> *texto*\n    .replace(/###\\s*/g, '')         // Elimina encabezados ###\n    .replace(/[¡¿!]/g, '');         // Elimina signos de exclamación e interrogación iniciales y finales\n\n  // Divide en líneas para análisis\n  const lines = processedText.split('\\n');\n\n  // Grupos para almacenar los mensajes\n  const messages = [];\n  let currentMessage = [];\n  let inNumberedSection = false;\n  let currentSectionNumber = null;\n\n  // Detectar secciones numeradas y agrupables\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    // Detecta si la línea es un encabezado numerado (ej: \"1. Tipo de propiedad:\")\n    const numberedHeaderMatch = line.match(/^\\s*(\\d+)\\.\\s+([^:]+):/);\n\n    if (numberedHeaderMatch) {\n      const sectionNumber = parseInt(numberedHeaderMatch[1]);\n\n      // Si estamos empezando una nueva sección numerada O si el número no es el siguiente esperado\n      if (!inNumberedSection || (inNumberedSection && sectionNumber !== currentSectionNumber + 1)) {\n        // Si tenemos contenido previo, guardamos como mensaje separado\n        if (currentMessage.length > 0) {\n          messages.push(currentMessage.join('\\n').trim());\n          currentMessage = [];\n        }\n        inNumberedSection = true;\n      }\n      currentSectionNumber = sectionNumber;\n      currentMessage.push(line);\n\n    } else if (line.trim() === '') {\n      // Una línea vacía puede terminar una sección si hay contenido previo\n      if (currentMessage.length > 0) {\n        // Si no estamos en una sección numerada, una línea vacía termina el mensaje actual\n        if (!inNumberedSection) {\n          messages.push(currentMessage.join('\\n').trim());\n          currentMessage = [];\n        } else {\n          // Si estamos en una sección numerada, una línea vacía se agrega al mensaje actual\n          currentMessage.push(line);\n        }\n      }\n\n    } else {\n      // Línea con contenido que no es un encabezado numerado\n      currentMessage.push(line);\n      inNumberedSection = false;\n    }\n  }\n\n  // Agregar el último mensaje si queda algo\n  if (currentMessage.length > 0) {\n    messages.push(currentMessage.join('\\n').trim());\n  }\n\n  // Filtrar mensajes vacíos y limpiar líneas vacías extra\n  return messages\n    .filter(msg => msg.length > 0)\n    .map(msg => {\n      // Eliminar líneas vacías múltiples dentro del mensaje\n      return msg.replace(/\\n{2,}/g, '\\n\\n');\n    });\n}\n\n// Función para extraer texto de diferentes estructuras de datos\nfunction extractTextContent(data) {\n  // Si la data es null o undefined, retornamos null inmediatamente\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  // Si es un string, lo retornamos directamente\n  if (typeof data === 'string') {\n    return data;\n  }\n\n  // Si es un array\n  if (Array.isArray(data)) {\n    // Iteramos sobre el array e intentamos extraer texto de cada elemento\n    for (const item of data) {\n      const extracted = extractTextContent(item);\n      if (extracted) {\n        return extracted;\n      }\n    }\n    return null;\n  }\n\n  // Si es un objeto\n  if (typeof data === 'object') {\n    // Priorizamos campos comunes que suelen contener texto\n    if (data.text) {\n      return data.text;\n    }\n    if (data.message) {\n      return data.message;\n    }\n    // Si tiene un campo 'output', intentamos extraer texto de él\n    if (data.output !== undefined && data.output !== null) {\n      const extracted = extractTextContent(data.output);\n      if (extracted) {\n        return extracted;\n      }\n    }\n    // Si tiene un campo 'response', intentamos extraer texto de él\n    if (data.response !== undefined && data.response !== null) {\n      const extracted = extractTextContent(data.response);\n      if (extracted) {\n        return extracted;\n      }\n    }\n    // Si tiene un campo 'json', intentamos extraer texto de él\n    if (data.json !== undefined && data.json !== null) {\n      const extracted = extractTextContent(data.json);\n      if (extracted) {\n        return extracted;\n      }\n    }\n    // Si no encontramos campos de texto comunes ni estructuras anidadas esperadas,\n    // intentamos convertir el objeto completo a string como último recurso\n    try {\n      return JSON.stringify(data);\n    } catch (e) {\n      console.error(\"No se pudo serializar el objeto a string en extractTextContent:\", e);\n      return null;\n    }\n  }\n\n  // Si el tipo de dato no es manejado, retornamos null\n  console.warn(\"Tipo de dato no manejado en extractTextContent:\", typeof data);\n  return null;\n}\n\n// --- Lógica Principal con manejo seguro de nodos ---\nlet textToProcess = null;\n\ntry {\n  // Verificar si el nodo \"Cancelar evento\" existe y tiene datos\n  let cancelarEventoData = null;\n  try {\n    // Usamos try-catch para capturar errores si el nodo no existe\n    cancelarEventoData = $('Cancelar evento');\n    if (cancelarEventoData && cancelarEventoData.first() && cancelarEventoData.first().json) {\n      if (cancelarEventoData.first().json.response !== undefined) {\n        textToProcess = extractTextContent(cancelarEventoData.first().json.response);\n      } else {\n        textToProcess = extractTextContent(cancelarEventoData.first().json);\n      }\n    }\n  } catch (e) {\n    // Silenciosamente ignoramos errores si el nodo no existe\n    console.log(\"Nodo 'Cancelar evento' no disponible o sin datos válidos\");\n  }\n  \n  // Solo intentamos acceder a AGE3 si aún no hemos encontrado texto para procesar\n  if (!textToProcess) {\n    try {\n      // Usamos try-catch para capturar errores si el nodo no existe\n      const age3Data = $('AGE3');\n      if (age3Data && age3Data.first() && age3Data.first().json) {\n        if (age3Data.first().json.output !== undefined) {\n          textToProcess = extractTextContent(age3Data.first().json.output);\n        } else {\n          textToProcess = extractTextContent(age3Data.first().json);\n        }\n      }\n    } catch (e) {\n      // Silenciosamente ignoramos errores si el nodo no existe\n      console.log(\"Nodo 'AGE3' no disponible o sin datos válidos\");\n    }\n  }\n  \n  // Si no hemos encontrado datos en los nodos específicos, intentamos con $input directamente\n  if (!textToProcess) {\n    try {\n      const inputItems = $input.all();\n      if (inputItems && inputItems.length > 0 && inputItems[0].json) {\n        textToProcess = extractTextContent(inputItems[0].json);\n      }\n    } catch (e) {\n      console.log(\"No se pudo acceder a los datos de entrada directamente:\", e.message);\n    }\n  }\n  \n  // Procesar y retornar el resultado\n  if (textToProcess) {\n    const textArray = processAndSplitText(textToProcess);\n    \n    // Procesar cada mensaje y dividirlo en chunks si es necesario\n    const processedMessages = [];\n    \n    for (const message of textArray) {\n      if (needsSplitting(message)) {\n        // Si el mensaje es largo, lo dividimos en chunks\n        const chunks = splitTextIntoChunks(message);\n        processedMessages.push(...chunks);\n      } else {\n        // Si el mensaje es corto, lo agregamos tal cual con tiempo de lectura\n        processedMessages.push({\n          parte: processedMessages.length + 1,\n          texto: message,\n          time: calculateReadingTime(message)\n        });\n      }\n    }\n    \n    // Re-numerar las partes para que sean consecutivas\n    processedMessages.forEach((msg, index) => {\n      msg.parte = index + 1;\n    });\n    \n    // Devolvemos la estructura con los mensajes procesados\n    return [{json: {messages: processedMessages, totalParts: processedMessages.length}}];\n  } else {\n    // Si no se pudo obtener ni procesar texto, devolvemos un array vacío\n    return [{json: {messages: [], totalParts: 0}}];\n  }\n} catch (error) {\n  // Capturamos cualquier error no manejado y devolvemos un objeto con información del error\n  console.error(\"Error general en el nodo:\", error.message);\n  return [{json: {messages: [], totalParts: 0, error: error.message}}];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        -48
      ],
      "id": "6d493eac-52de-44c8-845f-0bbf4c54b389",
      "name": "Separa datos1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://us.api-wa.me/2522xe636258b15/message/text",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "to",
              "value": "={{ $('limpiamos msg').item.json.telefono }}"
            },
            {
              "name": "text",
              "value": "={{ $('Loop Over Items1').item.json.texto }}"
            },
            {
              "name": "status",
              "value": "recording"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1440,
        128
      ],
      "id": "706ee027-c7b5-406d-8877-9f6524404713",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1216,
        48
      ],
      "id": "e9df5016-4675-473a-bbb2-2b6a0146cf68",
      "name": "Wait1",
      "webhookId": "aa8c0ee9-ac10-4c70-9b62-1402bc6d08f5"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://us.api-wa.me/2522xe636258b15/message/presence",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "to",
              "value": "={{ $('V1').first().json.msg.telefono }}"
            },
            {
              "name": "status",
              "value": "composing"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        992,
        48
      ],
      "id": "fc830765-6749-4ece-9a2d-b1f06714d8b2",
      "name": "escribiendo...1",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "0b7bfc46-f915-40ce-b3d8-c4942809f4f1",
              "leftValue": "={{ $json.output }}",
              "rightValue": "FINALIZADO",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -448,
        -48
      ],
      "id": "f3b2fc10-3433-4da2-85b5-3ec8e7199637",
      "name": "If4"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "=user:{{ $('Edit Fields').item.json.usuario }}",
        "sessionTTL": 600
      },
      "type": "@n8n/n8n-nodes-langchain.memoryRedisChat",
      "typeVersion": 1.5,
      "position": [
        -592,
        240
      ],
      "id": "cba61634-99a6-4958-b694-418eb27b6f29",
      "name": "memory2",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Edit Fields').item.json.usuario }}",
        "sessionTTL": 1800
      },
      "type": "@n8n/n8n-nodes-langchain.memoryRedisChat",
      "typeVersion": 1.5,
      "position": [
        -1440,
        32
      ],
      "id": "302c1c39-d10d-49c2-8b9e-2882b313133f",
      "name": "memory",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b9c23b07-71b1-4888-849a-09ecb880aa5e",
                    "leftValue": "={{ $json.message.match(/usuario:\\d+:ultimomsg/) !== null }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Usuario"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f68e054f-389b-4cec-a32a-c922fe60c99f",
                    "leftValue": "={{ $json.message.match(/user:\\d+:status/) !== null }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Reinicio"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -2096,
        112
      ],
      "id": "8f6d2b7c-75a7-4469-88cb-409beb9ce00f",
      "name": "Switch"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://us.api-wa.me/2522xe636258b15/message/text",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "to",
              "value": "={{ $('usuario').first().json.usuario }}"
            },
            {
              "name": "text",
              "value": "={{ $('Loop Over Items1').item.json.texto }}"
            },
            {
              "name": "status",
              "value": "recording"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1616,
        304
      ],
      "id": "721e4708-e374-4380-b95f-98554f1017fc",
      "name": "HTTP Request1"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=usuario:{{ $('Edit Fields').item.json.usuario }}:ultimomsg",
        "value": "esperando",
        "expire": true,
        "ttl": 120
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1616,
        -32
      ],
      "id": "2449b720-c2bd-4032-abae-a19b81c31b05",
      "name": "ultimoMsg1",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c34ea9fc-ce79-478f-9c07-e4e6a6eed15d",
              "name": "usuario",
              "value": "={{ ($json.message.match(/user:(\\d+):state/) || [])[1] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1856,
        304
      ],
      "id": "a296d4bd-5a01-436b-8000-76a4723aa480",
      "name": "usuario"
    },
    {
      "parameters": {
        "operation": "incr",
        "key": "=contador:{{ $('Edit Fields').first().json.usuario }}:recordatorio",
        "expire": true,
        "ttl": 3600
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1776,
        -256
      ],
      "id": "e14c8cec-0706-4274-be5d-0a9b36e27fab",
      "name": "Redis",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "contador",
        "key": "=contador:{{ $('Edit Fields').first().json.usuario }}:recordatorio",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        960,
        -224
      ],
      "id": "841aced2-bce6-43f6-9c9a-e5113e0f5777",
      "name": "contador de mensajes",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "b5e7258e-4262-49bb-afe6-5f1f81a0854e",
              "leftValue": "={{ $json.contador }}",
              "rightValue": 2,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1216,
        -272
      ],
      "id": "55e5a174-2d75-405b-86ba-2b94ff5dc440",
      "name": "Envio el 3er msg?"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=usuario:{{ $('Edit Fields').item.json.usuario }}:ultimomsg",
        "value": "esperando",
        "expire": true,
        "ttl": 540
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1504,
        -288
      ],
      "id": "d78461d1-679f-4f6c-a035-cd59a4e4cca9",
      "name": "ultimoMsg",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    }
  ],
  "pinData": {
    "ultimoMsg1": [
      {
        "json": {
          "status": 200,
          "data": {
            "key": {
              "remoteJid": "5492254423359@s.whatsapp.net",
              "fromMe": true,
              "id": "3EB0B187109E256E127C37"
            },
            "message": {
              "extendedTextMessage": {
                "text": "Hay algo más en lo que pueda ayudarte hoy?"
              }
            },
            "messageTimestamp": "1755520743",
            "status": "PENDING"
          }
        }
      }
    ],
    "Redis Trigger": [
      {
        "json": {
          "channel": "__keyevent@0__:expired",
          "message": "usuario:5492254423359:ultimomsg"
        }
      }
    ]
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-08-18T13:18:59.540Z",
  "versionId": "3ef214d4-e7b9-4bb1-a665-7c3c5853125a"
}