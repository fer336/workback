{
  "active": false,
  "connections": {
    "Calendario": {
      "main": [
        [
          {
            "node": "Redis1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis1": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response null Codigo1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lista": {
      "main": [
        [
          {
            "node": "HTTP Request2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "getForCode": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "getForCode",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Success2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Lista",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Datos de la propiedad",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Datos de la propiedad1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lista1": {
      "main": [
        [
          {
            "node": "HTTP Request4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out1": {
      "main": [
        [
          {
            "node": "getForCode2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Success4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Lista1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "getForCode2": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Datos de la propiedad1": {
      "main": [
        [
          {
            "node": "Get many events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Datos de la propiedad": {
      "main": [
        [
          {
            "node": "Get many events1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request2": {
      "main": [
        [
          {
            "node": "Success1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request4": {
      "main": [
        [
          {
            "node": "Success3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many events": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many events1": {
      "main": [
        [
          {
            "node": "Split Out1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-06-28T03:55:52.693Z",
  "id": "BMc2xdmYnikYsHl6",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "AGENTE INMO - Consultar_fechas_disponibles",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "Evento"
            },
            {
              "name": "numero_telefono"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1168,
        720
      ],
      "id": "8a2ad227-15b1-4707-b054-ea8949b7bbde",
      "name": "Calendario"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "Codigo_propiedad",
        "key": "=propiedades_historial_analisis:{{ $json.numero_telefono }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -944,
        720
      ],
      "id": "1c736bf1-d0ab-4e4b-82ca-f03d85e87bfe",
      "name": "Redis1",
      "credentials": {
        "redis": {
          "id": "f1mfRViKXHypdB9h",
          "name": "Redis account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "c358838a-4034-4100-a5cd-e89f533161b0",
              "leftValue": "={{ $json.ultimoCodigo }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -496,
        720
      ],
      "id": "18df77b7-bdb2-4ad2-a169-9cdab2375362",
      "name": "If"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ef619c87-8996-4278-805f-187d5e1e672a",
              "name": "response",
              "value": "Codigo propiedad vacio",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -304,
        992
      ],
      "id": "916ee84e-182a-455c-ae87-2bb15567c806",
      "name": "Response null Codigo1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "39c2f302-03be-4464-a17a-d7cc481d6d44",
              "name": "=response",
              "value": "=LISTA_ENVIADA",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "29997547-f0d8-4081-8379-0b0df0ab09c1",
      "name": "Success1",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1552,
        1264
      ]
    },
    {
      "parameters": {
        "jsCode": "// Funci√≥n para convertir hora de 24h a 12h con AM/PM\nfunction convertirA12Horas(hora24) {\n  const [horas, minutos] = hora24.split(':').map(Number);\n  const periodo = horas >= 12 ? 'PM' : 'AM';\n  const horas12 = horas % 12 || 12; // Convertir 0 a 12 para medianoche\n  return `${horas12}:${minutos.toString().padStart(2, '0')} ${periodo}`;\n}\n\n// Funci√≥n para formatear el rango de hora correctamente con AM/PM\nfunction formatearRangoHora(horaInicio, horaFin) {\n  const inicioMatch = horaInicio.match(/^(\\d+):(\\d+)/);\n  const finMatch = horaFin.match(/^(\\d+):(\\d+)/);\n  \n  const horaInicioFormateada = inicioMatch ? `${inicioMatch[1]}:${inicioMatch[2]}` : horaInicio;\n  const horaFinFormateada = finMatch ? `${finMatch[1]}:${finMatch[2]}` : horaFin;\n  \n  // CAMBIO: Convertir a formato 12 horas con AM/PM\n  const inicio12 = convertirA12Horas(horaInicioFormateada);\n  const fin12 = convertirA12Horas(horaFinFormateada);\n  \n  return `${inicio12} a ${fin12}`;\n}\n\n// Funci√≥n para crear fecha en formato ISO con timezone de Argentina\nfunction crearFechaISO(anio, mes, dia, hora) {\n  // Parsear la hora (formato \"HH:MM\")\n  const [horas, minutos] = hora.split(':').map(Number);\n  \n  // Crear fecha en timezone de Argentina\n  const fecha = new Date(anio, mes - 1, dia, horas, minutos, 0);\n  \n  // Formatear en ISO simple sin prefijos\n  const year = fecha.getFullYear();\n  const month = String(fecha.getMonth() + 1).padStart(2, '0');\n  const day = String(fecha.getDate()).padStart(2, '0');\n  const hour = String(fecha.getHours()).padStart(2, '0');\n  const minute = String(fecha.getMinutes()).padStart(2, '0');\n  \n  // Retornar formato ISO limpio\n  return `${year}-${month}-${day}T${hour}:${minute}:00.000-03:00`;\n}\n\n// Obtener los datos del nodo anterior\nconst datos = $input.first()?.json?.resultados || [];\nconsole.log(\"DEBUG - Datos recibidos:\", JSON.stringify(datos).substring(0, 200) + \"...\");\n\n// Tel√©fono del cliente din√°mico - obtener de nodo Calendario\nlet remoteJid = \"\";\ntry {\n  const numeroTelefono = $('Calendario').first().json.numero_telefono;\n  remoteJid = numeroTelefono || \"\";\n  console.log(\"DEBUG - N√∫mero obtenido del nodo Calendario:\", numeroTelefono);\n} catch (error) {\n  console.log(\"ERROR - No se pudo obtener numero_telefono:\", error.message);\n  remoteJid = \"\"; // N√∫mero vac√≠o por defecto\n}\n\n// Verificar si tenemos datos\nif (!datos || !datos.length) {\n  console.log(\"DEBUG - No hay datos disponibles\");\n  \n  const mensajeSinFechas = {\n    to: remoteJid,\n    type: \"text\",\n    text: `üìÖüïí *AGENDA DIGITAL* üïíüìÖ\\n\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\nüìÜ *Informaci√≥n de Horarios*\\n\\nActualmente no hay fechas disponibles.\\n\\nPor favor, intenta nuevamente m√°s tarde. üôè\\n\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`\n  };\n  \n  console.log(\"DEBUG - Enviando mensaje sin fechas a:\", remoteJid);\n  return [{ json: mensajeSinFechas }];\n}\n\n// Funci√≥n para obtener el emoji estacional seg√∫n el mes (hemisferio sur)\nfunction getEmojiEstacional(mes) {\n  if (mes >= 3 && mes <= 5) return \"üçÇ\"; // Oto√±o\n  if (mes >= 6 && mes <= 8) return \"‚ùÑÔ∏è\"; // Invierno\n  if (mes >= 9 && mes <= 11) return \"üå∏\"; // Primavera\n  return \"‚òÄÔ∏è\"; // Verano\n}\n\n// Nombres de los meses\nconst nombresMeses = {\n  1: 'Enero', 2: 'Febrero', 3: 'Marzo', 4: 'Abril',\n  5: 'Mayo', 6: 'Junio', 7: 'Julio', 8: 'Agosto',\n  9: 'Septiembre', 10: 'Octubre', 11: 'Noviembre', 12: 'Diciembre'\n};\n\n// Nombres de los d√≠as de la semana\nconst nombresDias = {\n  0: 'Domingo', 1: 'Lunes', 2: 'Martes', 3: 'Mi√©rcoles',\n  4: 'Jueves', 5: 'Viernes', 6: 'S√°bado'\n};\n\n// Extraer fecha de una cadena ISO\nfunction extraerFechaYHora(isoString) {\n  if (!isoString) return null;\n  \n  const match = isoString.match(/(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2})/);\n  if (match) {\n    const fechaCompleta = new Date(`${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:00`);\n    const diaSemana = nombresDias[fechaCompleta.getDay()];\n    \n    return {\n      anio: parseInt(match[1], 10),\n      mes: parseInt(match[2], 10),\n      dia: parseInt(match[3], 10),\n      hora: `${match[4]}:${match[5]}`,\n      fechaCompleta: fechaCompleta,\n      diaSemana: diaSemana\n    };\n  }\n  return null;\n}\n\n// Obtener la fecha y hora actual\nconst ahora = new Date();\nconsole.log(`DEBUG - Fecha actual: ${ahora.toISOString()}`);\n\n// Agrupar horarios por mes (igual que categor√≠as en el primer c√≥digo)\nconst mesesAgrupados = {};\n\n// Procesar los horarios disponibles de todos los eventos\ndatos.forEach(evento => {\n  if (!evento.horariosDisponibles || !evento.horariosDisponibles.length) return;\n  \n  evento.horariosDisponibles.forEach(horario => {\n    try {\n      const fechaHorario = new Date(horario.inicio);\n      \n      console.log(`DEBUG - Evaluando horario: ${horario.inicio}`);\n      \n      // Verificar si la fecha ya pas√≥\n      if (fechaHorario <= ahora) {\n        console.log(`DEBUG - FILTRADA: Fecha ya pas√≥`);\n        return;\n      }\n      \n      const fechaInicio = extraerFechaYHora(horario.inicio);\n      if (!fechaInicio) {\n        console.log(`DEBUG - Error al extraer fecha y hora de: ${horario.inicio}`);\n        return;\n      }\n      \n      const mes = fechaInicio.mes;\n      const dia = fechaInicio.dia;\n      const nombreMes = nombresMeses[mes];\n      const diaSemana = fechaInicio.diaSemana;\n      \n      // Inicializar el grupo del mes si no existe (como categor√≠as)\n      if (!mesesAgrupados[nombreMes]) mesesAgrupados[nombreMes] = [];\n\n      // Evitar duplicados\n      const yaExiste = mesesAgrupados[nombreMes].some(\n        e => e.dia === dia && e.horaInicio === horario.horaInicio\n      );\n      \n      if (!yaExiste) {\n        // Crear fecha ISO para el rowId\n        const fechaISO = crearFechaISO(fechaInicio.anio, fechaInicio.mes, fechaInicio.dia, horario.horaInicio);\n        \n        mesesAgrupados[nombreMes].push({\n          id: fechaISO, // El ID ser√° la fecha en formato ISO\n          dia: dia,\n          horaInicio: horario.horaInicio,\n          horaFin: horario.horaFin,\n          mes: mes,\n          diaSemana: diaSemana,\n          resumen: evento.eventoPrincipal.resumen || \"\"\n        });\n      }\n    } catch (error) {\n      console.log(`ERROR procesando horario: ${error.message}`);\n    }\n  });\n});\n\n// Orden de meses (como orden de categor√≠as en el primer c√≥digo)\nconst ordenMeses = [\n  \"Enero\", \"Febrero\", \"Marzo\", \"Abril\", \"Mayo\", \"Junio\",\n  \"Julio\", \"Agosto\", \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"\n];\n\n// Filtro de b√∫squeda (igual que en el primer c√≥digo)\nlet consultaUsuario = \"\";\ntry {\n  consultaUsuario = $('Workflow Input Trigger').first().json.query.Descripcion || \"\";\n} catch {\n  consultaUsuario = \"\";\n}\n\nif (consultaUsuario && consultaUsuario.trim() !== \"\") {\n  const mesesFiltrados = {};\n  let hayFechasFiltradas = false;\n\n  for (const mes in mesesAgrupados) {\n    if (mes.toLowerCase().includes(consultaUsuario.toLowerCase())) {\n      mesesFiltrados[mes] = mesesAgrupados[mes];\n      hayFechasFiltradas = true;\n    } else {\n      const filtrados = mesesAgrupados[mes].filter(f =>\n        f.diaSemana.toLowerCase().includes(consultaUsuario.toLowerCase()) ||\n        f.resumen.toLowerCase().includes(consultaUsuario.toLowerCase())\n      );\n      if (filtrados.length > 0) {\n        mesesFiltrados[mes] = filtrados;\n        hayFechasFiltradas = true;\n      }\n    }\n  }\n  if (hayFechasFiltradas) {\n    for (const key in mesesAgrupados) delete mesesAgrupados[key];\n    Object.assign(mesesAgrupados, mesesFiltrados);\n  }\n}\n\n// Ordenar meses (como categor√≠as ordenadas)\nconst mesesOrdenados = Object.keys(mesesAgrupados).sort((a, b) => {\n  const idxA = ordenMeses.indexOf(a);\n  const idxB = ordenMeses.indexOf(b);\n  if (idxA !== -1 && idxB !== -1) return idxA - idxB;\n  if (idxA !== -1) return -1;\n  if (idxB !== -1) return 1;\n  return a.localeCompare(b);\n});\n\n// Crear sections (igual que en el primer c√≥digo)\nconst sections = [];\n\nfor (const nombreMes of mesesOrdenados) {\n  const fechas = mesesAgrupados[nombreMes];\n  if (fechas.length === 0) continue;\n\n  // Ordenar fechas por d√≠a y hora (como productos por nombre)\n  fechas.sort((a, b) => {\n    if (a.dia !== b.dia) return a.dia - b.dia;\n    return a.horaInicio.localeCompare(b.horaInicio);\n  });\n\n  // Obtener emoji estacional para el mes\n  const emojiMes = getEmojiEstacional(fechas[0].mes);\n\n  // Crear rows exactamente como en las capturas\n  const rows = fechas.map(f => {\n    const horaFormateada = formatearRangoHora(f.horaInicio, f.horaFin);\n    \n    return {\n      id: f.id, // Este ser√° el formato ISO: 2025-05-30T12:30:00.000-03:00\n      title: `üïí ${f.dia} de ${nombreMes} : ${horaFormateada}`,\n      description: `${f.diaSemana}`\n    };\n  });\n\n  // Agregar section con formato exacto de las capturas\n  sections.push({\n    title: `${emojiMes} ${nombreMes}`,\n    rows\n  });\n}\n\n// T√≠tulo del calendario (simple como en las capturas)\nconst tituloCita = \"üìÖ Fechas Disponibles\";\n\n// Objetos header, body, footer y action EXACTAMENTE como las capturas\nconst headerObj = {\n  text: tituloCita\n};\n\nconst bodyObj = {\n  text: `Seleccion√° una fecha y hora para agendar tu visita\\nüïí Cada visita tiene una duraci√≥n de 30 minutos aprox.`\n};\n\nconst footerObj = {\n  text: \"\"\n};\n\nconst actionObj = {\n  list: {\n    sections: sections,\n    label: \"Seleccion√° üëÜ\"\n  }\n};\n\n// Request body EXACTAMENTE igual al primer c√≥digo\nconst requestBody = {\n  header: headerObj,\n  body: bodyObj,\n  footer: footerObj,\n  action: actionObj,\n  type: \"list\",\n  to: remoteJid\n};\n\nconsole.log(\"DEBUG - N√∫mero final para env√≠o:\", remoteJid);\nconsole.log(\"DEBUG - Request body generado:\", JSON.stringify(requestBody, null, 2));\n\nreturn [{ json: requestBody }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        1264
      ],
      "id": "0618cee2-7416-40cc-9433-377671579ee6",
      "name": "Lista"
    },
    {
      "parameters": {
        "jsCode": "// C√≥digo para obtener el √∫ltimo c√≥digo de propiedad\n// Obtenemos todos los √≠tems de Redis\nconst redisItems =$input.first().json.Codigo_propiedad ;\n\n// Verificamos si existe la propiedad y es un array\nif (!Array.isArray(redisItems)) {\n  console.log(\"Error: No se encontr√≥ un array de c√≥digos de propiedad\");\n  return $input.all();\n}\n\n// Obtenemos el √∫ltimo elemento del array\nconst ultimoCodigo = redisItems[redisItems.length - 1];\nconsole.log(\"√öltimo c√≥digo de propiedad:\", ultimoCodigo);\n\n// A√±adimos el √∫ltimo c√≥digo a todos los √≠tems de entrada\nconst items = $input.all();\nfor (const item of items) {\n  item.json.ultimoCodigo = ultimoCodigo;\n}\n\n// Devolvemos los √≠tems con el nuevo campo\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        720
      ],
      "id": "d63cf344-4813-41ab-b61b-aa1a7208f1b6",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// üöÄ AN√ÅLISIS DEL C√ìDIGO ORIGINAL Y MEJORAS\n\n// === LO QUE HACE EL C√ìDIGO ACTUAL ===\n// 1. Busca eventos que contengan \"CODIGO:XXXXX\" en el summary\n// 2. Los trata como eventos disponibles (colorId 10)\n// 3. Divide cada evento en bloques de 30 minutos\n// 4. Devuelve los horarios disponibles\n\n// === C√ìDIGO MEJORADO CON TIEMPO DIN√ÅMICO ===\n\nconsole.log(\"=== GENERADOR DE HORARIOS DISPONIBLES ===\");\n\n// üöÄ Leer datos de entrada\nconst eventos = $input.all();\nconst codigoBusqueda = $('Code').first().json.ultimoCodigo?.toUpperCase();\nconst tiempoReserva = $('Datos de la propiedad1').first().json.Tiempo; // ‚≠ê NUEVA VARIABLE\n\nconsole.log(\"C√≥digo a buscar:\", codigoBusqueda);\nconsole.log(\"Tiempo de reserva original:\", tiempoReserva);\n\n// Validar datos de entrada\nif (!codigoBusqueda) {\n    console.log(\"‚ùå No se proporcion√≥ c√≥digo de b√∫squeda\");\n    return [{\n        json: {\n            error: true,\n            message: \"No se proporcion√≥ c√≥digo de b√∫squeda\"\n        }\n    }];\n}\n\nif (!tiempoReserva) {\n    console.log(\"‚ùå No se proporcion√≥ tiempo de reserva\");\n    return [{\n        json: {\n            error: true,\n            message: \"No se proporcion√≥ tiempo de reserva\"\n        }\n    }];\n}\n\n// üöÄ PARSEAR EL TIEMPO CORRECTAMENTE (ej: \"1hs\" = 60min, \"30min\" = 30min)\nconst parsearTiempo = (tiempoStr) => {\n    if (!tiempoStr || typeof tiempoStr !== 'string') {\n        return null;\n    }\n    \n    const tiempoLower = tiempoStr.toLowerCase().trim();\n    console.log(\"Parseando tiempo:\", tiempoLower);\n    \n    // Buscar patrones como \"1hs\", \"2hs\", \"30min\", \"45min\", etc.\n    if (tiempoLower.includes('hs') || tiempoLower.includes('hora')) {\n        // Extraer n√∫mero de horas\n        const horasMatch = tiempoLower.match(/(\\d+(?:\\.\\d+)?)\\s*(?:hs|hora)/);\n        if (horasMatch) {\n            const horas = parseFloat(horasMatch[1]);\n            const minutos = horas * 60;\n            console.log(`${horas} horas = ${minutos} minutos`);\n            return minutos;\n        }\n    } else if (tiempoLower.includes('min')) {\n        // Extraer n√∫mero de minutos\n        const minutosMatch = tiempoLower.match(/(\\d+(?:\\.\\d+)?)\\s*min/);\n        if (minutosMatch) {\n            const minutos = parseFloat(minutosMatch[1]);\n            console.log(`${minutos} minutos`);\n            return minutos;\n        }\n    } else {\n        // Intentar parsear como n√∫mero directo (asumir minutos)\n        const numero = parseFloat(tiempoLower);\n        if (!isNaN(numero)) {\n            console.log(`N√∫mero directo: ${numero} (asumiendo minutos)`);\n            return numero;\n        }\n    }\n    \n    return null;\n};\n\nconst tiempoReservaMin = parsearTiempo(tiempoReserva);\n\nif (tiempoReservaMin === null || tiempoReservaMin <= 0) {\n    console.log(\"‚ùå No se pudo parsear el tiempo de reserva:\", tiempoReserva);\n    return [{\n        json: {\n            error: true,\n            message: `Formato de tiempo inv√°lido: \"${tiempoReserva}\". Use formatos como \"1hs\", \"30min\", etc.`\n        }\n    }];\n}\n\nconsole.log(\"Tiempo de reserva convertido:\", tiempoReservaMin, \"minutos\");\n\n// ‚≠ê CONTAR EVENTOS ROJOS BAS√ÅNDOSE EN colorId\nlet eventosRojosData = [];\nlet contadorEventosRojos = 0;\n\ntry {\n    console.log(\"\\nüîç Analizando todos los eventos para encontrar eventos rojos (colorId = 11)...\");\n    \n    // Recorrer todos los eventos de entrada para encontrar los rojos\n    eventos.forEach((item, index) => {\n        const evento = item.json;\n        \n        // Verificar si es un evento rojo (colorId = 11)\n        const esEventoRojo = evento.colorId === 11 || evento.colorId === \"11\";\n        \n        console.log(`Evento ${index + 1}: colorId = ${evento.colorId}, ¬øEs rojo? ${esEventoRojo}`);\n        \n        if (esEventoRojo) {\n            // Filtrar eventos que no tienen fechas v√°lidas\n            const start = evento.start?.dateTime || evento.start?.date || evento.start;\n            const end = evento.end?.dateTime || evento.end?.date || evento.end;\n            \n            if (start && end && \n                start !== \"America/Argentina/Buenos_Aires\" && \n                end !== \"America/Argentina/Buenos_Aires\") {\n                \n                eventosRojosData.push(evento);\n                contadorEventosRojos++;\n                \n                console.log(`‚úÖ Evento rojo v√°lido encontrado: ${evento.summary || 'Sin t√≠tulo'}`);\n            } else {\n                console.log(`‚ùå Evento rojo descartado por fechas inv√°lidas`);\n            }\n        }\n    });\n    \n    console.log(`üìä Total eventos rojos encontrados: ${contadorEventosRojos}`);\n    \n} catch (error) {\n    console.log(\"‚ö†Ô∏è Error al analizar eventos rojos:\", error.message);\n    eventosRojosData = [];\n    contadorEventosRojos = 0;\n}\n\nconsole.log(\"Eventos rojos encontrados:\", contadorEventosRojos);\nconsole.log(\"Datos de eventos rojos:\", eventosRojosData);\n\n// üöÄ Funciones auxiliares mejoradas\nconst extraerMinutos = (isoString) => {\n    if (!isoString) return null;\n    try {\n        console.log(\"Extrayendo minutos de:\", isoString);\n        \n        // PROBLEMA: JavaScript convierte autom√°ticamente a timezone local\n        // Necesitamos extraer la hora directamente del string ISO\n        \n        // Buscar el patr√≥n de hora en el string ISO: YYYY-MM-DDTHH:MM:SS\n        const horaMatch = isoString.match(/T(\\d{2}):(\\d{2}):(\\d{2})/);\n        \n        if (horaMatch) {\n            const horas = parseInt(horaMatch[1]);\n            const minutos = parseInt(horaMatch[2]);\n            const totalMinutos = horas * 60 + minutos;\n            \n            console.log(`Hora extra√≠da directamente: ${horas}:${minutos.toString().padStart(2, '0')} = ${totalMinutos} minutos`);\n            return totalMinutos;\n        }\n        \n        // Fallback: usar Date object (puede tener problemas de timezone)\n        const fecha = new Date(isoString);\n        const totalMinutosFallback = fecha.getHours() * 60 + fecha.getMinutes();\n        console.log(`Fallback con Date object: ${fecha.getHours()}:${fecha.getMinutes()} = ${totalMinutosFallback} minutos`);\n        console.log(`Fecha completa: ${fecha.toString()}`);\n        \n        return totalMinutosFallback;\n    } catch (error) {\n        console.log(\"Error parseando fecha:\", isoString, error);\n        return null;\n    }\n};\n\nconst minutosAHora = (totalMinutos) => {\n    const horas = Math.floor(totalMinutos / 60);\n    const minutos = totalMinutos % 60;\n    return `${horas.toString().padStart(2, '0')}:${minutos.toString().padStart(2, '0')}`;\n};\n\nconst crearFechaISO = (fechaBase, horaStr) => {\n    try {\n        console.log(\"Creando fecha ISO con:\");\n        console.log(\"- fechaBase:\", fechaBase);\n        console.log(\"- horaStr:\", horaStr);\n        \n        // Extraer la parte de fecha (YYYY-MM-DD) y timezone del string original\n        const fechaMatch = fechaBase.match(/^(\\d{4}-\\d{2}-\\d{2})T.*?([-+]\\d{2}:\\d{2})$/);\n        \n        if (fechaMatch) {\n            const fechaParte = fechaMatch[1]; // 2025-05-30\n            const timezone = fechaMatch[2]; // -03:00\n            \n            // Crear nueva fecha manteniendo la timezone original\n            const nuevaFechaISO = `${fechaParte}T${horaStr}:00${timezone}`;\n            console.log(\"Nueva fecha ISO creada:\", nuevaFechaISO);\n            \n            return nuevaFechaISO;\n        }\n        \n        // Fallback: reemplazar solo la parte de hora\n        const fechaModificada = fechaBase.replace(/T\\d{2}:\\d{2}/, `T${horaStr}`);\n        console.log(\"Fecha modificada (fallback):\", fechaModificada);\n        \n        return fechaModificada;\n    } catch (error) {\n        console.log(\"Error creando fecha ISO:\", fechaBase, horaStr, error);\n        return fechaBase;\n    }\n};\n\n// üöÄ Recolectar eventos v√°lidos\nconsole.log(\"\\n--- BUSCANDO EVENTOS ---\");\nconst eventosDisponibles = [];\n\nfor (const item of eventos) {\n    const ev = item.json;\n    const start = ev.start?.dateTime || ev.start?.date || ev.start;\n    const end = ev.end?.dateTime || ev.end?.date || ev.end;\n    \n    // Filtrar elementos que no tienen fecha v√°lida\n    if (!start || !end || \n        start === \"America/Argentina/Buenos_Aires\" || \n        end === \"America/Argentina/Buenos_Aires\") {\n        console.log(\"‚è≠Ô∏è Saltando evento sin fechas v√°lidas\");\n        continue;\n    }\n    \n    const summary = ev.summary || \"\";\n    \n    // Buscar si summary contiene \"Codigo:XXXXX\"\n    const summaryUpper = summary.toUpperCase();\n    const patronBusqueda = \"CODIGO:\" + codigoBusqueda;\n    const coincide = summaryUpper.includes(patronBusqueda);\n    \n    console.log(`üìÖ Evento: \"${summary}\"`);\n    console.log(`üîç Buscando: \"${patronBusqueda}\"`);\n    console.log(`‚úÖ ¬øCoincide? ${coincide}`);\n    \n    if (coincide) {\n        // Validar que las fechas se puedan parsear\n        const fechaInicio = new Date(start);\n        const fechaFin = new Date(end);\n        \n        if (isNaN(fechaInicio.getTime()) || isNaN(fechaFin.getTime())) {\n            console.log(\"‚ùå Fechas inv√°lidas en evento:\", start, end);\n            continue;\n        }\n        \n        eventosDisponibles.push({ \n            start, \n            end, \n            summary, \n            location: ev.location || \"\",\n            colorId: \"10\",\n            fechaInicioParsed: fechaInicio.toISOString(),\n            fechaFinParsed: fechaFin.toISOString()\n        });\n        \n        console.log(\"‚úÖ Evento agregado a disponibles\");\n    }\n}\n\nconsole.log(`\\nüìä Total eventos disponibles encontrados: ${eventosDisponibles.length}`);\n\n// üöÄ Procesar eventos rojos (visitas agendadas) para exclusi√≥n\nconsole.log(\"\\n--- PROCESANDO EVENTOS ROJOS (OCUPADOS) ---\");\nconst bloquesOcupados = [];\n\n// Validar que hay eventos rojos para procesar\nif (contadorEventosRojos === 0) {\n    console.log(\"‚ÑπÔ∏è No hay eventos rojos (colorId = 11) para procesar. Todos los horarios estar√°n disponibles.\");\n} else {\n    console.log(`‚úÖ ${contadorEventosRojos} eventos rojos encontrados, procesando exclusiones...`);\n\n    // Procesar cada evento rojo encontrado\n    eventosRojosData.forEach((eventoRojo, index) => {\n        console.log(`\\nüî¥ Procesando evento rojo ${index + 1}:`);\n        console.log(\"ColorId:\", eventoRojo.colorId);\n        console.log(\"Summary:\", eventoRojo.summary || \"Sin t√≠tulo\");\n        console.log(\"Evento completo:\", JSON.stringify(eventoRojo, null, 2));\n        \n        // Extraer fechas del evento rojo\n        let fechaInicioRojo, fechaFinRojo;\n        \n        if (eventoRojo.start && eventoRojo.start.dateTime) {\n            fechaInicioRojo = eventoRojo.start.dateTime;\n        } else if (eventoRojo.start) {\n            fechaInicioRojo = eventoRojo.start;\n        }\n        \n        if (eventoRojo.end && eventoRojo.end.dateTime) {\n            fechaFinRojo = eventoRojo.end.dateTime;\n        } else if (eventoRojo.end) {\n            fechaFinRojo = eventoRojo.end;\n        }\n        \n        if (fechaInicioRojo && fechaFinRojo) {\n            const inicioMin = extraerMinutos(fechaInicioRojo);\n            const finMin = extraerMinutos(fechaFinRojo);\n            \n            if (inicioMin !== null && finMin !== null) {\n                // Extraer fecha base (YYYY-MM-DD) para comparar con eventos disponibles\n                const fechaBaseMatch = fechaInicioRojo.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n                const fechaBase = fechaBaseMatch ? fechaBaseMatch[1] : null;\n                \n                const bloqueOcupado = {\n                    fechaBase: fechaBase,\n                    inicioMin: inicioMin,\n                    finMin: finMin,\n                    fechaInicioCompleta: fechaInicioRojo,\n                    fechaFinCompleta: fechaFinRojo,\n                    summary: eventoRojo.summary || \"Visita agendada\",\n                    colorId: eventoRojo.colorId\n                };\n                \n                bloquesOcupados.push(bloqueOcupado);\n                \n                console.log(`‚úÖ Bloque ocupado: ${fechaBase} de ${minutosAHora(inicioMin)} a ${minutosAHora(finMin)} (${eventoRojo.summary || 'Sin t√≠tulo'})`);\n            } else {\n                console.log(\"‚ùå No se pudieron extraer minutos del evento rojo\");\n            }\n        } else {\n            console.log(\"‚ùå No se pudieron extraer fechas del evento rojo\");\n        }\n    });\n}\n\nconsole.log(`\\nüìã Total bloques ocupados: ${bloquesOcupados.length}`);\n\n// Funci√≥n para verificar si un bloque est√° ocupado\nconst estaOcupado = (fechaBase, inicioMin, finMin) => {\n    return bloquesOcupados.some(ocupado => {\n        // Debe ser la misma fecha\n        if (ocupado.fechaBase !== fechaBase) return false;\n        \n        // Verificar superposici√≥n de tiempo:\n        // Un bloque est√° ocupado si hay ANY superposici√≥n con un evento rojo\n        const haySuperpocision = (\n            // El nuevo bloque empieza antes de que termine el ocupado Y\n            inicioMin < ocupado.finMin &&\n            // El nuevo bloque termina despu√©s de que empiece el ocupado\n            finMin > ocupado.inicioMin\n        );\n        \n        if (haySuperpocision) {\n            console.log(`‚ùå Bloque ${minutosAHora(inicioMin)}-${minutosAHora(finMin)} ocupado por: ${ocupado.summary}`);\n        }\n        \n        return haySuperpocision;\n    });\n};\n\n// üöÄ Si no hay eventos disponibles\nif (eventosDisponibles.length === 0) {\n    return [{\n        json: {\n            noMatchingEvents: true,\n            message: `No se encontraron eventos disponibles para el c√≥digo: ${codigoBusqueda}`,\n            debug: {\n                codigoBuscado: codigoBusqueda,\n                patronBusqueda: \"CODIGO:\" +codigoBusqueda,\n                totalEventosAnalizados: eventos.length\n            }\n        }\n    }];\n}\n\n// üöÄ Procesar horarios disponibles con tiempo din√°mico\nconsole.log(`\\n--- GENERANDO BLOQUES DE ${tiempoReservaMin} MINUTOS ---`);\n\nconst resultados = eventosDisponibles.map((evento, index) => {\n    console.log(`\\nüèóÔ∏è Procesando evento ${index + 1}: \"${evento.summary}\"`);\n    \n    const inicioEventoMin = extraerMinutos(evento.start);\n    const finEventoMin = extraerMinutos(evento.end);\n    \n    if (inicioEventoMin === null || finEventoMin === null) {\n        console.log(\"‚ùå No se pudieron extraer minutos del evento\");\n        return {\n            eventoPrincipal: {\n                resumen: evento.summary,\n                location: evento.location,\n                inicio: evento.start,\n                fin: evento.end,\n                colorId: \"10\",\n                error: \"No se pudieron procesar las horas\"\n            },\n            horariosDisponibles: []\n        };\n    }\n    \n    console.log(`‚è∞ Evento de ${minutosAHora(inicioEventoMin)} a ${minutosAHora(finEventoMin)}`);\n    console.log(`üìè Duraci√≥n total: ${finEventoMin - inicioEventoMin} minutos`);\n    \n    // Crear bloques basados en el tiempo de reserva\n    const bloques = [];\n    let bloquesGenerados = 0;\n    let bloquesExcluidos = 0;\n    \n    // Extraer fecha base del evento para comparar con eventos rojos\n    const fechaBaseEvento = evento.start.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n    const fechaBase = fechaBaseEvento ? fechaBaseEvento[1] : null;\n    \n    for (let m = inicioEventoMin; m + tiempoReservaMin <= finEventoMin; m += tiempoReservaMin) {\n        const horaInicio = minutosAHora(m);\n        const horaFin = minutosAHora(m + tiempoReservaMin);\n        \n        // ‚≠ê VERIFICAR SI ESTE BLOQUE EST√Å OCUPADO\n        const bloqueOcupado = estaOcupado(fechaBase, m, m + tiempoReservaMin);\n        \n        if (bloqueOcupado) {\n            bloquesExcluidos++;\n            console.log(`  ‚ùå Bloque ${horaInicio} - ${horaFin} EXCLUIDO (ocupado)`);\n            continue; // Saltar este bloque\n        }\n        \n        const bloque = {\n            horaInicio: horaInicio,\n            horaFin: horaFin,\n            inicio: crearFechaISO(evento.start, horaInicio),\n            fin: crearFechaISO(evento.start, horaFin),\n            duracionMinutos: tiempoReservaMin\n        };\n        \n        bloques.push(bloque);\n        bloquesGenerados++;\n        \n        console.log(`  ‚úÖ Bloque ${bloquesGenerados}: ${horaInicio} - ${horaFin} DISPONIBLE`);\n    }\n    \n    console.log(`‚úÖ Total bloques disponibles: ${bloquesGenerados}`);\n    console.log(`‚ùå Total bloques excluidos: ${bloquesExcluidos}`);\n    \n    return {\n        eventoPrincipal: {\n            resumen: evento.summary,\n            location: evento.location,\n            inicio: evento.start,\n            fin: evento.end,\n            horaInicio: minutosAHora(inicioEventoMin),\n            horaFin: minutosAHora(finEventoMin),\n            colorId: \"10\",\n            duracionTotalMinutos: finEventoMin - inicioEventoMin,\n            tiempoReservaMinutos: tiempoReservaMin\n        },\n        horariosDisponibles: bloques,\n        estadisticas: {\n            totalBloques: bloquesGenerados,\n            bloquesExcluidos: bloquesExcluidos,\n            duracionBloque: tiempoReservaMin,\n            duracionEvento: finEventoMin - inicioEventoMin\n        }\n    };\n});\n\n// üöÄ Calcular estad√≠sticas generales\nconst totalBloques = resultados.reduce((sum, resultado) => sum + resultado.horariosDisponibles.length, 0);\nconst totalExcluidos = resultados.reduce((sum, resultado) => sum + (resultado.estadisticas?.bloquesExcluidos || 0), 0);\n\nconsole.log(`\\nüìà RESUMEN FINAL:`);\nconsole.log(`- Eventos disponibles: ${eventosDisponibles.length}`);\nconsole.log(`- Total bloques de tiempo DISPONIBLES: ${totalBloques}`);\nconsole.log(`- Total bloques EXCLUIDOS (ocupados): ${totalExcluidos}`);\nconsole.log(`- Duraci√≥n por bloque: ${tiempoReservaMin} minutos`);\nconsole.log(`- Eventos rojos (colorId=11) encontrados: ${contadorEventosRojos}`);\n\n// üöÄ Devolver la respuesta\nreturn [{\n    json: {\n        resultados: resultados,\n        resumen: {\n            codigoBuscado: codigoBusqueda,\n            tiempoReservaMinutos: tiempoReservaMin,\n            eventosEncontrados: eventosDisponibles.length,\n            totalBloquesDisponibles: totalBloques,\n            totalBloquesExcluidos: totalExcluidos,\n            eventosRojosEncontrados: contadorEventosRojos\n        }\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        704,
        1168
      ],
      "id": "bf50816c-e090-4310-a7d6-bb4cce2da83b",
      "name": "getForCode"
    },
    {
      "parameters": {
        "fieldToSplitOut": "summary, start, end, location, colorId, description, id",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        528,
        1168
      ],
      "id": "79a56e48-4d3b-4272-8bef-25bde48dc0af",
      "name": "Split Out"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b272870f-2db7-43e9-b82f-131ed3160b38",
              "leftValue": "={{ $json.message }}",
              "rightValue": "=No se encontraron eventos disponibles para la propiedad.",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        880,
        1168
      ],
      "id": "b0b48037-0e41-414d-8a5c-935476d866a9",
      "name": "If1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "39c2f302-03be-4464-a17a-d7cc481d6d44",
              "name": "=response",
              "value": "=No hay evento cargados para esta propiedad",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "086421b5-b125-46dc-9bc5-393126c291e0",
      "name": "Success2",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1104,
        1072
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "435d1553-cd6c-4d79-85c9-bf9b09fef4fd",
              "leftValue": "={{ $('Calendario').item.json.Evento }}",
              "rightValue": "reagendar",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -240,
        640
      ],
      "id": "04be4245-a195-4288-aac0-5810b8eb0d79",
      "name": "If2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "39c2f302-03be-4464-a17a-d7cc481d6d44",
              "name": "=response",
              "value": "=LISTA_ENVIADA",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "d94aca9f-9d6b-439c-9db3-a69f9b3879bb",
      "name": "Success3",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1664,
        368
      ]
    },
    {
      "parameters": {
        "jsCode": "// Obtener los datos del nodo anterior\nconst datos = $input.first()?.json?.resultados || [];\nconsole.log(\"DEBUG - Datos recibidos:\", JSON.stringify(datos).substring(0, 200) + \"...\");\n\n// Verificar si tenemos datos\nif (!datos || !datos.length) {\n  console.log(\"DEBUG - No hay datos disponibles\");\n  return [{\n    json: {\n      to: $('Calendario').first().json.numero_cliente || \"\",\n      type: \"text\",\n      text: \"No hay fechas disponibles para reprogramar la visita en este momento. Intent√° m√°s tarde.\"\n    },\n    pairedItem: 0\n  }];\n}\n\n// Funci√≥n para convertir hora de 24h a 12h con AM/PM\nfunction convertirA12Horas(hora24) {\n  const [horas, minutos] = hora24.split(':').map(Number);\n  const periodo = horas >= 12 ? 'PM' : 'AM';\n  const horas12 = horas % 12 || 12; // Convertir 0 a 12 para medianoche\n  return `${horas12}:${minutos.toString().padStart(2, '0')} ${periodo}`;\n}\n\n// Funci√≥n para obtener el emoji estacional seg√∫n el mes (hemisferio sur)\nfunction getEmojiEstacional(mes) {\n  if (mes >= 3 && mes <= 5) return \"üçÇ\";\n  if (mes >= 6 && mes <= 8) return \"‚ùÑÔ∏è\";\n  if (mes >= 9 && mes <= 11) return \"üå∏\";\n  return \"‚òÄÔ∏è\";\n}\n\nconst nombresMeses = {\n  1: 'Enero', 2: 'Febrero', 3: 'Marzo', 4: 'Abril',\n  5: 'Mayo', 6: 'Junio', 7: 'Julio', 8: 'Agosto',\n  9: 'Septiembre', 10: 'Octubre', 11: 'Noviembre', 12: 'Diciembre'\n};\nconst nombresDias = {\n  0: 'Domingo', 1: 'Lunes', 2: 'Martes', 3: 'Mi√©rcoles',\n  4: 'Jueves', 5: 'Viernes', 6: 'S√°bado'\n};\n\nfunction extraerFechaYHora(isoString) {\n  if (!isoString) return null;\n  const match = isoString.match(/(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2})/);\n  if (match) {\n    const fechaCompleta = new Date(`${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:00`);\n    const diaSemana = nombresDias[fechaCompleta.getDay()];\n    return {\n      anio: parseInt(match[1], 10),\n      mes: parseInt(match[2], 10),\n      dia: parseInt(match[3], 10),\n      hora: `${match[4]}:${match[5]}`,\n      fechaCompleta: fechaCompleta,\n      diaSemana: diaSemana\n    };\n  }\n  return null;\n}\n\nfunction formatearRangoHora(horaInicio, horaFin) {\n  // CAMBIO: Convertir ambas horas a formato 12h con AM/PM\n  const inicioMatch = horaInicio.match(/^(\\d+):(\\d+)/);\n  const finMatch = horaFin.match(/^(\\d+):(\\d+)/);\n  \n  const horaInicioFormateada = inicioMatch ? `${inicioMatch[1]}:${inicioMatch[2]}` : horaInicio;\n  const horaFinFormateada = finMatch ? `${finMatch[1]}:${finMatch[2]}` : horaFin;\n  \n  // Convertir a formato 12 horas\n  const inicio12 = convertirA12Horas(horaInicioFormateada);\n  const fin12 = convertirA12Horas(horaFinFormateada);\n  \n  return `${inicio12} a ${fin12}`;\n}\n\nconst ahora = new Date();\n\n// Agrupar horarios por mes, guardando el a√±o real para el ISO\nconst mesesAgrupados = {};\ndatos.forEach(evento => {\n  if (!evento.horariosDisponibles || !evento.horariosDisponibles.length) return;\n  evento.horariosDisponibles.forEach(horario => {\n    try {\n      const fechaHorario = new Date(horario.inicio);\n      if (fechaHorario <= ahora) return;\n      const fechaInicio = extraerFechaYHora(horario.inicio);\n      if (!fechaInicio) return;\n      const mes = fechaInicio.mes;\n      const dia = fechaInicio.dia;\n      const anio = fechaInicio.anio; // <- A√ëO REAL!\n      const nombreMes = nombresMeses[mes];\n      const diaSemana = fechaInicio.diaSemana;\n      if (!mesesAgrupados[nombreMes]) mesesAgrupados[nombreMes] = [];\n      const yaExiste = mesesAgrupados[nombreMes].some(\n        e => e.dia === dia && e.horaInicio === horario.horaInicio\n      );\n      if (!yaExiste) {\n        mesesAgrupados[nombreMes].push({\n          id: null, // Se define luego (ISO)\n          anio,\n          mes,\n          dia,\n          horaInicio: horario.horaInicio,\n          horaFin: horario.horaFin,\n          diaSemana,\n          resumen: evento.eventoPrincipal ? evento.eventoPrincipal.resumen : \"\"\n        });\n      }\n    } catch (error) {\n      console.log(`ERROR procesando horario: ${error.message}`);\n    }\n  });\n});\n\n// Crear sections en formato SendList WHAPI\nconst sections = [];\nconst ordenMeses = [\n  \"Enero\", \"Febrero\", \"Marzo\", \"Abril\", \"Mayo\", \"Junio\",\n  \"Julio\", \"Agosto\", \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"\n];\nconst mesesOrdenados = Object.keys(mesesAgrupados).sort((a, b) => {\n  const idxA = ordenMeses.indexOf(a);\n  const idxB = ordenMeses.indexOf(b);\n  if (idxA !== -1 && idxB !== -1) return idxA - idxB;\n  if (idxA !== -1) return -1;\n  if (idxB !== -1) return 1;\n  return a.localeCompare(b);\n});\nfor (const nombreMes of mesesOrdenados) {\n  const filas = mesesAgrupados[nombreMes];\n  if (filas.length === 0) continue;\n  const mes = filas[0].mes;\n  const emoji = getEmojiEstacional(mes);\n\n  filas.sort((a, b) => {\n    if (a.dia !== b.dia) return a.dia - b.dia;\n    return a.horaInicio.localeCompare(b.horaInicio);\n  });\n\n  const rows = filas.map(f => {\n    // Armar fecha ISO con a√±o real\n    const mesIso = String(f.mes).padStart(2, '0');\n    const diaIso = String(f.dia).padStart(2, '0');\n    const horaIso = f.horaInicio.length === 5 ? f.horaInicio : f.horaInicio.padStart(5, '0');\n    const fechaIso = `${f.anio}-${mesIso}-${diaIso}T${horaIso}`; // Ej: 2025-05-29T15:42\n    return {\n      id: fechaIso, // row_id en formato ISO corto\n      title: `üïí ${f.dia} de ${nombreMes} : ${formatearRangoHora(f.horaInicio, f.horaFin)}`,\n      description: `${f.diaSemana}`\n    };\n  });\n\n  if (rows.length > 0) {\n    sections.push({\n      title: `${emoji} ${nombreMes}`,\n      rows\n    });\n  }\n}\n\n// Obtener n√∫mero de cliente desde otro nodo o poner uno por defecto\nconst remoteJid = $('Calendario').first().json.numero_cliente || \"\";\n\n// JSON final para enviar por WhatsApp (formato WHAPI SendList unificado)\nconst headerObj = {\n  text: \"üìÖ Fechas de Reprogramaci√≥n\"\n};\nconst bodyObj = {\n  text: `Seleccion√° una nueva fecha y hora para reprogramar tu visita.\\nüïí Cada visita tiene una duraci√≥n de 30 minutos aprox.`\n};\nconst footerObj = {\n  text: \"\"\n};\nconst actionObj = {\n  list: {\n    sections: sections,\n    label: \"Seleccion√° üëÜ\"\n  }\n};\n\nconst requestBody = {\n  header: headerObj,\n  body: bodyObj,\n  footer: footerObj,\n  action: actionObj,\n  type: \"list\",\n  to: remoteJid\n};\n\n// Retornar el mensaje final en el formato que espera n8n\nreturn [{\n  json: requestBody,\n  pairedItem: 0\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        368
      ],
      "id": "aecb0916-138c-4a80-a3d9-5886028a135b",
      "name": "Lista1"
    },
    {
      "parameters": {
        "fieldToSplitOut": "summary, start, end, location, colorId, description, id",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        560,
        272
      ],
      "id": "ea45a413-c93c-4c4e-920e-c33d18daee5f",
      "name": "Split Out1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "b272870f-2db7-43e9-b82f-131ed3160b38",
              "leftValue": "={{ $json.resultados[0].horariosDisponibles }}",
              "rightValue": "=",
              "operator": {
                "type": "array",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1008,
        272
      ],
      "id": "f4c3b1ba-68d3-4ab0-94d0-a38db821750a",
      "name": "If3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "39c2f302-03be-4464-a17a-d7cc481d6d44",
              "name": "=response",
              "value": "=No hay evento cargados para esta propiedad",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "ddfa322c-7bdb-40c1-bd6a-cd77794eed3a",
      "name": "Success4",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1232,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "// üöÄ AN√ÅLISIS DEL C√ìDIGO ORIGINAL Y MEJORAS\n\n// === LO QUE HACE EL C√ìDIGO ACTUAL ===\n// 1. Busca eventos que contengan \"CODIGO:XXXXX\" en el summary\n// 2. Los trata como eventos disponibles (colorId 10)\n// 3. Divide cada evento en bloques de 30 minutos\n// 4. Devuelve los horarios disponibles\n\n// === C√ìDIGO MEJORADO CON TIEMPO DIN√ÅMICO ===\n\nconsole.log(\"=== GENERADOR DE HORARIOS DISPONIBLES ===\");\n\n// üöÄ Leer datos de entrada\nconst eventos = $input.all();\nconst codigoBusqueda = $('Code').first().json.ultimoCodigo?.toUpperCase();\nconst tiempoReserva = $('Datos de la propiedad').first().json.Tiempo; // ‚≠ê NUEVA VARIABLE\n\nconsole.log(\"C√≥digo a buscar:\", codigoBusqueda);\nconsole.log(\"Tiempo de reserva original:\", tiempoReserva);\n\n// Validar datos de entrada\nif (!codigoBusqueda) {\n    console.log(\"‚ùå No se proporcion√≥ c√≥digo de b√∫squeda\");\n    return [{\n        json: {\n            error: true,\n            message: \"No se proporcion√≥ c√≥digo de b√∫squeda\"\n        }\n    }];\n}\n\nif (!tiempoReserva) {\n    console.log(\"‚ùå No se proporcion√≥ tiempo de reserva\");\n    return [{\n        json: {\n            error: true,\n            message: \"No se proporcion√≥ tiempo de reserva\"\n        }\n    }];\n}\n\n// üöÄ PARSEAR EL TIEMPO CORRECTAMENTE (ej: \"1hs\" = 60min, \"30min\" = 30min)\nconst parsearTiempo = (tiempoStr) => {\n    if (!tiempoStr || typeof tiempoStr !== 'string') {\n        return null;\n    }\n    \n    const tiempoLower = tiempoStr.toLowerCase().trim();\n    console.log(\"Parseando tiempo:\", tiempoLower);\n    \n    // Buscar patrones como \"1hs\", \"2hs\", \"30min\", \"45min\", etc.\n    if (tiempoLower.includes('hs') || tiempoLower.includes('hora')) {\n        // Extraer n√∫mero de horas\n        const horasMatch = tiempoLower.match(/(\\d+(?:\\.\\d+)?)\\s*(?:hs|hora)/);\n        if (horasMatch) {\n            const horas = parseFloat(horasMatch[1]);\n            const minutos = horas * 60;\n            console.log(`${horas} horas = ${minutos} minutos`);\n            return minutos;\n        }\n    } else if (tiempoLower.includes('min')) {\n        // Extraer n√∫mero de minutos\n        const minutosMatch = tiempoLower.match(/(\\d+(?:\\.\\d+)?)\\s*min/);\n        if (minutosMatch) {\n            const minutos = parseFloat(minutosMatch[1]);\n            console.log(`${minutos} minutos`);\n            return minutos;\n        }\n    } else {\n        // Intentar parsear como n√∫mero directo (asumir minutos)\n        const numero = parseFloat(tiempoLower);\n        if (!isNaN(numero)) {\n            console.log(`N√∫mero directo: ${numero} (asumiendo minutos)`);\n            return numero;\n        }\n    }\n    \n    return null;\n};\n\nconst tiempoReservaMin = parsearTiempo(tiempoReserva);\n\nif (tiempoReservaMin === null || tiempoReservaMin <= 0) {\n    console.log(\"‚ùå No se pudo parsear el tiempo de reserva:\", tiempoReserva);\n    return [{\n        json: {\n            error: true,\n            message: `Formato de tiempo inv√°lido: \"${tiempoReserva}\". Use formatos como \"1hs\", \"30min\", etc.`\n        }\n    }];\n}\n\nconsole.log(\"Tiempo de reserva convertido:\", tiempoReservaMin, \"minutos\");\n\n// ‚≠ê CONTAR EVENTOS ROJOS BAS√ÅNDOSE EN colorId\nlet eventosRojosData = [];\nlet contadorEventosRojos = 0;\n\ntry {\n    console.log(\"\\nüîç Analizando todos los eventos para encontrar eventos rojos (colorId = 11)...\");\n    \n    // Recorrer todos los eventos de entrada para encontrar los rojos\n    eventos.forEach((item, index) => {\n        const evento = item.json;\n        \n        // Verificar si es un evento rojo (colorId = 11)\n        const esEventoRojo = evento.colorId === 11 || evento.colorId === \"11\";\n        \n        console.log(`Evento ${index + 1}: colorId = ${evento.colorId}, ¬øEs rojo? ${esEventoRojo}`);\n        \n        if (esEventoRojo) {\n            // Filtrar eventos que no tienen fechas v√°lidas\n            const start = evento.start?.dateTime || evento.start?.date || evento.start;\n            const end = evento.end?.dateTime || evento.end?.date || evento.end;\n            \n            if (start && end && \n                start !== \"America/Argentina/Buenos_Aires\" && \n                end !== \"America/Argentina/Buenos_Aires\") {\n                \n                eventosRojosData.push(evento);\n                contadorEventosRojos++;\n                \n                console.log(`‚úÖ Evento rojo v√°lido encontrado: ${evento.summary || 'Sin t√≠tulo'}`);\n            } else {\n                console.log(`‚ùå Evento rojo descartado por fechas inv√°lidas`);\n            }\n        }\n    });\n    \n    console.log(`üìä Total eventos rojos encontrados: ${contadorEventosRojos}`);\n    \n} catch (error) {\n    console.log(\"‚ö†Ô∏è Error al analizar eventos rojos:\", error.message);\n    eventosRojosData = [];\n    contadorEventosRojos = 0;\n}\n\nconsole.log(\"Eventos rojos encontrados:\", contadorEventosRojos);\nconsole.log(\"Datos de eventos rojos:\", eventosRojosData);\n\n// üöÄ Funciones auxiliares mejoradas\nconst extraerMinutos = (isoString) => {\n    if (!isoString) return null;\n    try {\n        console.log(\"Extrayendo minutos de:\", isoString);\n        \n        // PROBLEMA: JavaScript convierte autom√°ticamente a timezone local\n        // Necesitamos extraer la hora directamente del string ISO\n        \n        // Buscar el patr√≥n de hora en el string ISO: YYYY-MM-DDTHH:MM:SS\n        const horaMatch = isoString.match(/T(\\d{2}):(\\d{2}):(\\d{2})/);\n        \n        if (horaMatch) {\n            const horas = parseInt(horaMatch[1]);\n            const minutos = parseInt(horaMatch[2]);\n            const totalMinutos = horas * 60 + minutos;\n            \n            console.log(`Hora extra√≠da directamente: ${horas}:${minutos.toString().padStart(2, '0')} = ${totalMinutos} minutos`);\n            return totalMinutos;\n        }\n        \n        // Fallback: usar Date object (puede tener problemas de timezone)\n        const fecha = new Date(isoString);\n        const totalMinutosFallback = fecha.getHours() * 60 + fecha.getMinutes();\n        console.log(`Fallback con Date object: ${fecha.getHours()}:${fecha.getMinutes()} = ${totalMinutosFallback} minutos`);\n        console.log(`Fecha completa: ${fecha.toString()}`);\n        \n        return totalMinutosFallback;\n    } catch (error) {\n        console.log(\"Error parseando fecha:\", isoString, error);\n        return null;\n    }\n};\n\nconst minutosAHora = (totalMinutos) => {\n    const horas = Math.floor(totalMinutos / 60);\n    const minutos = totalMinutos % 60;\n    return `${horas.toString().padStart(2, '0')}:${minutos.toString().padStart(2, '0')}`;\n};\n\nconst crearFechaISO = (fechaBase, horaStr) => {\n    try {\n        console.log(\"Creando fecha ISO con:\");\n        console.log(\"- fechaBase:\", fechaBase);\n        console.log(\"- horaStr:\", horaStr);\n        \n        // Extraer la parte de fecha (YYYY-MM-DD) y timezone del string original\n        const fechaMatch = fechaBase.match(/^(\\d{4}-\\d{2}-\\d{2})T.*?([-+]\\d{2}:\\d{2})$/);\n        \n        if (fechaMatch) {\n            const fechaParte = fechaMatch[1]; // 2025-05-30\n            const timezone = fechaMatch[2]; // -03:00\n            \n            // Crear nueva fecha manteniendo la timezone original\n            const nuevaFechaISO = `${fechaParte}T${horaStr}:00${timezone}`;\n            console.log(\"Nueva fecha ISO creada:\", nuevaFechaISO);\n            \n            return nuevaFechaISO;\n        }\n        \n        // Fallback: reemplazar solo la parte de hora\n        const fechaModificada = fechaBase.replace(/T\\d{2}:\\d{2}/, `T${horaStr}`);\n        console.log(\"Fecha modificada (fallback):\", fechaModificada);\n        \n        return fechaModificada;\n    } catch (error) {\n        console.log(\"Error creando fecha ISO:\", fechaBase, horaStr, error);\n        return fechaBase;\n    }\n};\n\n// üöÄ Recolectar eventos v√°lidos\nconsole.log(\"\\n--- BUSCANDO EVENTOS ---\");\nconst eventosDisponibles = [];\n\nfor (const item of eventos) {\n    const ev = item.json;\n    const start = ev.start?.dateTime || ev.start?.date || ev.start;\n    const end = ev.end?.dateTime || ev.end?.date || ev.end;\n    \n    // Filtrar elementos que no tienen fecha v√°lida\n    if (!start || !end || \n        start === \"America/Argentina/Buenos_Aires\" || \n        end === \"America/Argentina/Buenos_Aires\") {\n        console.log(\"‚è≠Ô∏è Saltando evento sin fechas v√°lidas\");\n        continue;\n    }\n    \n    const summary = ev.summary || \"\";\n    \n    // Buscar si summary contiene \"Codigo:XXXXX\"\n    const summaryUpper = summary.toUpperCase();\n    const patronBusqueda = \"CODIGO:\" + codigoBusqueda;\n    const coincide = summaryUpper.includes(patronBusqueda);\n    \n    console.log(`üìÖ Evento: \"${summary}\"`);\n    console.log(`üîç Buscando: \"${patronBusqueda}\"`);\n    console.log(`‚úÖ ¬øCoincide? ${coincide}`);\n    \n    if (coincide) {\n        // Validar que las fechas se puedan parsear\n        const fechaInicio = new Date(start);\n        const fechaFin = new Date(end);\n        \n        if (isNaN(fechaInicio.getTime()) || isNaN(fechaFin.getTime())) {\n            console.log(\"‚ùå Fechas inv√°lidas en evento:\", start, end);\n            continue;\n        }\n        \n        eventosDisponibles.push({ \n            start, \n            end, \n            summary, \n            location: ev.location || \"\",\n            colorId: \"10\",\n            fechaInicioParsed: fechaInicio.toISOString(),\n            fechaFinParsed: fechaFin.toISOString()\n        });\n        \n        console.log(\"‚úÖ Evento agregado a disponibles\");\n    }\n}\n\nconsole.log(`\\nüìä Total eventos disponibles encontrados: ${eventosDisponibles.length}`);\n\n// üöÄ Procesar eventos rojos (visitas agendadas) para exclusi√≥n\nconsole.log(\"\\n--- PROCESANDO EVENTOS ROJOS (OCUPADOS) ---\");\nconst bloquesOcupados = [];\n\n// Validar que hay eventos rojos para procesar\nif (contadorEventosRojos === 0) {\n    console.log(\"‚ÑπÔ∏è No hay eventos rojos (colorId = 11) para procesar. Todos los horarios estar√°n disponibles.\");\n} else {\n    console.log(`‚úÖ ${contadorEventosRojos} eventos rojos encontrados, procesando exclusiones...`);\n\n    // Procesar cada evento rojo encontrado\n    eventosRojosData.forEach((eventoRojo, index) => {\n        console.log(`\\nüî¥ Procesando evento rojo ${index + 1}:`);\n        console.log(\"ColorId:\", eventoRojo.colorId);\n        console.log(\"Summary:\", eventoRojo.summary || \"Sin t√≠tulo\");\n        console.log(\"Evento completo:\", JSON.stringify(eventoRojo, null, 2));\n        \n        // Extraer fechas del evento rojo\n        let fechaInicioRojo, fechaFinRojo;\n        \n        if (eventoRojo.start && eventoRojo.start.dateTime) {\n            fechaInicioRojo = eventoRojo.start.dateTime;\n        } else if (eventoRojo.start) {\n            fechaInicioRojo = eventoRojo.start;\n        }\n        \n        if (eventoRojo.end && eventoRojo.end.dateTime) {\n            fechaFinRojo = eventoRojo.end.dateTime;\n        } else if (eventoRojo.end) {\n            fechaFinRojo = eventoRojo.end;\n        }\n        \n        if (fechaInicioRojo && fechaFinRojo) {\n            const inicioMin = extraerMinutos(fechaInicioRojo);\n            const finMin = extraerMinutos(fechaFinRojo);\n            \n            if (inicioMin !== null && finMin !== null) {\n                // Extraer fecha base (YYYY-MM-DD) para comparar con eventos disponibles\n                const fechaBaseMatch = fechaInicioRojo.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n                const fechaBase = fechaBaseMatch ? fechaBaseMatch[1] : null;\n                \n                const bloqueOcupado = {\n                    fechaBase: fechaBase,\n                    inicioMin: inicioMin,\n                    finMin: finMin,\n                    fechaInicioCompleta: fechaInicioRojo,\n                    fechaFinCompleta: fechaFinRojo,\n                    summary: eventoRojo.summary || \"Visita agendada\",\n                    colorId: eventoRojo.colorId\n                };\n                \n                bloquesOcupados.push(bloqueOcupado);\n                \n                console.log(`‚úÖ Bloque ocupado: ${fechaBase} de ${minutosAHora(inicioMin)} a ${minutosAHora(finMin)} (${eventoRojo.summary || 'Sin t√≠tulo'})`);\n            } else {\n                console.log(\"‚ùå No se pudieron extraer minutos del evento rojo\");\n            }\n        } else {\n            console.log(\"‚ùå No se pudieron extraer fechas del evento rojo\");\n        }\n    });\n}\n\nconsole.log(`\\nüìã Total bloques ocupados: ${bloquesOcupados.length}`);\n\n// Funci√≥n para verificar si un bloque est√° ocupado\nconst estaOcupado = (fechaBase, inicioMin, finMin) => {\n    return bloquesOcupados.some(ocupado => {\n        // Debe ser la misma fecha\n        if (ocupado.fechaBase !== fechaBase) return false;\n        \n        // Verificar superposici√≥n de tiempo:\n        // Un bloque est√° ocupado si hay ANY superposici√≥n con un evento rojo\n        const haySuperpocision = (\n            // El nuevo bloque empieza antes de que termine el ocupado Y\n            inicioMin < ocupado.finMin &&\n            // El nuevo bloque termina despu√©s de que empiece el ocupado\n            finMin > ocupado.inicioMin\n        );\n        \n        if (haySuperpocision) {\n            console.log(`‚ùå Bloque ${minutosAHora(inicioMin)}-${minutosAHora(finMin)} ocupado por: ${ocupado.summary}`);\n        }\n        \n        return haySuperpocision;\n    });\n};\n\n// üöÄ Si no hay eventos disponibles\nif (eventosDisponibles.length === 0) {\n    return [{\n        json: {\n            noMatchingEvents: true,\n            message: `No se encontraron eventos disponibles para el c√≥digo: ${codigoBusqueda}`,\n            debug: {\n                codigoBuscado: codigoBusqueda,\n                patronBusqueda: \"CODIGO:\" + codigoBusqueda,\n                totalEventosAnalizados: eventos.length\n            }\n        }\n    }];\n}\n\n// üöÄ Procesar horarios disponibles con tiempo din√°mico\nconsole.log(`\\n--- GENERANDO BLOQUES DE ${tiempoReservaMin} MINUTOS ---`);\n\nconst resultados = eventosDisponibles.map((evento, index) => {\n    console.log(`\\nüèóÔ∏è Procesando evento ${index + 1}: \"${evento.summary}\"`);\n    \n    const inicioEventoMin = extraerMinutos(evento.start);\n    const finEventoMin = extraerMinutos(evento.end);\n    \n    if (inicioEventoMin === null || finEventoMin === null) {\n        console.log(\"‚ùå No se pudieron extraer minutos del evento\");\n        return {\n            eventoPrincipal: {\n                resumen: evento.summary,\n                location: evento.location,\n                inicio: evento.start,\n                fin: evento.end,\n                colorId: \"10\",\n                error: \"No se pudieron procesar las horas\"\n            },\n            horariosDisponibles: []\n        };\n    }\n    \n    console.log(`‚è∞ Evento de ${minutosAHora(inicioEventoMin)} a ${minutosAHora(finEventoMin)}`);\n    console.log(`üìè Duraci√≥n total: ${finEventoMin - inicioEventoMin} minutos`);\n    \n    // Crear bloques basados en el tiempo de reserva\n    const bloques = [];\n    let bloquesGenerados = 0;\n    let bloquesExcluidos = 0;\n    \n    // Extraer fecha base del evento para comparar con eventos rojos\n    const fechaBaseEvento = evento.start.match(/^(\\d{4}-\\d{2}-\\d{2})/);\n    const fechaBase = fechaBaseEvento ? fechaBaseEvento[1] : null;\n    \n    for (let m = inicioEventoMin; m + tiempoReservaMin <= finEventoMin; m += tiempoReservaMin) {\n        const horaInicio = minutosAHora(m);\n        const horaFin = minutosAHora(m + tiempoReservaMin);\n        \n        // ‚≠ê VERIFICAR SI ESTE BLOQUE EST√Å OCUPADO\n        const bloqueOcupado = estaOcupado(fechaBase, m, m + tiempoReservaMin);\n        \n        if (bloqueOcupado) {\n            bloquesExcluidos++;\n            console.log(`  ‚ùå Bloque ${horaInicio} - ${horaFin} EXCLUIDO (ocupado)`);\n            continue; // Saltar este bloque\n        }\n        \n        const bloque = {\n            horaInicio: horaInicio,\n            horaFin: horaFin,\n            inicio: crearFechaISO(evento.start, horaInicio),\n            fin: crearFechaISO(evento.start, horaFin),\n            duracionMinutos: tiempoReservaMin\n        };\n        \n        bloques.push(bloque);\n        bloquesGenerados++;\n        \n        console.log(`  ‚úÖ Bloque ${bloquesGenerados}: ${horaInicio} - ${horaFin} DISPONIBLE`);\n    }\n    \n    console.log(`‚úÖ Total bloques disponibles: ${bloquesGenerados}`);\n    console.log(`‚ùå Total bloques excluidos: ${bloquesExcluidos}`);\n    \n    return {\n        eventoPrincipal: {\n            resumen: evento.summary,\n            location: evento.location,\n            inicio: evento.start,\n            fin: evento.end,\n            horaInicio: minutosAHora(inicioEventoMin),\n            horaFin: minutosAHora(finEventoMin),\n            colorId: \"10\",\n            duracionTotalMinutos: finEventoMin - inicioEventoMin,\n            tiempoReservaMinutos: tiempoReservaMin\n        },\n        horariosDisponibles: bloques,\n        estadisticas: {\n            totalBloques: bloquesGenerados,\n            bloquesExcluidos: bloquesExcluidos,\n            duracionBloque: tiempoReservaMin,\n            duracionEvento: finEventoMin - inicioEventoMin\n        }\n    };\n});\n\n// üöÄ Calcular estad√≠sticas generales\nconst totalBloques = resultados.reduce((sum, resultado) => sum + resultado.horariosDisponibles.length, 0);\nconst totalExcluidos = resultados.reduce((sum, resultado) => sum + (resultado.estadisticas?.bloquesExcluidos || 0), 0);\n\nconsole.log(`\\nüìà RESUMEN FINAL:`);\nconsole.log(`- Eventos disponibles: ${eventosDisponibles.length}`);\nconsole.log(`- Total bloques de tiempo DISPONIBLES: ${totalBloques}`);\nconsole.log(`- Total bloques EXCLUIDOS (ocupados): ${totalExcluidos}`);\nconsole.log(`- Duraci√≥n por bloque: ${tiempoReservaMin} minutos`);\nconsole.log(`- Eventos rojos (colorId=11) encontrados: ${contadorEventosRojos}`);\n\n// üöÄ Devolver la respuesta\nreturn [{\n    json: {\n        resultados: resultados,\n        resumen: {\n            codigoBuscado: codigoBusqueda,\n            tiempoReservaMinutos: tiempoReservaMin,\n            eventosEncontrados: eventosDisponibles.length,\n            totalBloquesDisponibles: totalBloques,\n            totalBloquesExcluidos: totalExcluidos,\n            eventosRojosEncontrados: contadorEventosRojos\n        }\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        272
      ],
      "id": "ecab3719-79ff-4086-8c80-098f9d3fa4e8",
      "name": "getForCode2"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1vxULMw6IdEF03hfs2a-svqJUTEuSWbW5wVUQkk88eU4",
          "mode": "list",
          "cachedResultName": "Cliente:00_urls_francisco",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1vxULMw6IdEF03hfs2a-svqJUTEuSWbW5wVUQkk88eU4/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "CRM",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1vxULMw6IdEF03hfs2a-svqJUTEuSWbW5wVUQkk88eU4/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "CODIGO",
              "lookupValue": "={{ $('Code').first().json.ultimoCodigo }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        128,
        272
      ],
      "id": "88f339c5-551d-467c-a7e4-5b39b60fd690",
      "name": "Datos de la propiedad",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "uyuvATuLJQlzto7q",
          "name": "google sheet"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1vxULMw6IdEF03hfs2a-svqJUTEuSWbW5wVUQkk88eU4",
          "mode": "list",
          "cachedResultName": "Cliente:00_urls_francisco",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1vxULMw6IdEF03hfs2a-svqJUTEuSWbW5wVUQkk88eU4/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "CRM",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1vxULMw6IdEF03hfs2a-svqJUTEuSWbW5wVUQkk88eU4/edit#gid=0"
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "CODIGO",
              "lookupValue": "={{ $json.ultimoCodigo }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        160,
        1168
      ],
      "id": "9e6ec407-613d-4e2c-afa8-bbd95f5bd1c7",
      "name": "Datos de la propiedad1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "uyuvATuLJQlzto7q",
          "name": "google sheet"
        }
      }
    },
    {
      "parameters": {
        "content": "## Fechas disponibles, muestra la disponiblidad de un codigo en especifico de propiedad",
        "height": 580,
        "width": 1820,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        32,
        912
      ],
      "typeVersion": 1,
      "id": "9c6852b5-dfc1-4064-98dd-9445be2a3e11",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "## Reagendar visita, envia lista ",
        "height": 660,
        "width": 1840,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1,
      "id": "e0af04f6-832b-4d52-8866-d4f3b6c1e4ad",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://gate.whapi.cloud/messages/interactive",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "header",
              "value": "={{ $json?.header || \" \" }}"
            },
            {
              "name": "body",
              "value": "={{ $json?.body || $json.text }}"
            },
            {
              "name": "footer",
              "value": "={{ $json?.footer || \" \" }}"
            },
            {
              "name": "action",
              "value": "={{ $json?.action || \"list\" }}"
            },
            {
              "name": "type",
              "value": "={{ $json.type }}"
            },
            {
              "name": "to",
              "value": "={{ $('Calendario').first().json.numero_telefono }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true,
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1328,
        1264
      ],
      "id": "12033aaa-84ab-4608-b1df-807a9999a7ea",
      "name": "HTTP Request2",
      "alwaysOutputData": true,
      "credentials": {
        "httpHeaderAuth": {
          "id": "ekaTMbiKps3wYx80",
          "name": "Whapi - Agente inmobiliario"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://gate.whapi.cloud/messages/interactive",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "authorization",
              "value": "Bearer B2v6DZyi27qmgYXOnvrYLEJ4l8KgN410"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "header",
              "value": "={{ $json.header }}"
            },
            {
              "name": "body",
              "value": "={{ $json.body }}"
            },
            {
              "name": "footer",
              "value": "={{ $json.footer }}"
            },
            {
              "name": "action",
              "value": "={{ $json.action }}"
            },
            {
              "name": "type",
              "value": "={{ $json.type }}"
            },
            {
              "name": "to",
              "value": "={{ $('Calendario').first().json.numero_telefono }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true,
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1440,
        368
      ],
      "id": "b7d5243b-8866-4821-b927-8bfccedef31f",
      "name": "HTTP Request4"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "004dfd8dfad8cab59884aa5afbe99b4943ba96c971d4eb480405c7595b8160b1@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Francisco"
        },
        "returnAll": true,
        "timeMax": "={{ $now.plus({ week: 2 }) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        352,
        1168
      ],
      "id": "1c96cf3e-6dca-4366-b554-40dd8fff48b8",
      "name": "Get many events",
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "b9dhe93V3wFhoVsL",
          "name": "Calendario Qeva Francisco"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "004dfd8dfad8cab59884aa5afbe99b4943ba96c971d4eb480405c7595b8160b1@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Francisco"
        },
        "returnAll": true,
        "timeMax": "={{ $now.plus({ week: 2 }) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        352,
        272
      ],
      "id": "60e7f9dc-0e3f-47c2-81b9-d6eabd2bdf88",
      "name": "Get many events1",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "b9dhe93V3wFhoVsL",
          "name": "Calendario Qeva Francisco"
        }
      }
    }
  ],
  "pinData": {
    "Calendario": [
      {
        "json": {
          "Evento": "reagendar",
          "numero_telefono": "5492254423359"
        }
      }
    ]
  },
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Argentina/Buenos_Aires",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "EBMwLGTBawYqkZM1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-07-29T06:15:51.151Z",
  "versionId": "653e3e4f-c482-49f9-865b-63028d381e4a"
}